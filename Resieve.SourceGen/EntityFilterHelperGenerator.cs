using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Resieve.SourceGen
{
    [Generator]
    public class EntityFilterHelperGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Register a syntax provider to find all record declarations in the compilation
            var recordDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    (node, _) => node is RecordDeclarationSyntax, // Only consider record declarations
                    (ctx, _) => (RecordDeclarationSyntax)ctx.Node)
                .Where(recordDecl => recordDecl != null);

            // For each record declaration, generate a filter helper class
            context.RegisterSourceOutput(
                recordDeclarations.Combine(context.CompilationProvider),
                (spc, tuple) =>
                {
                    // tuple contains the record declaration and the full compilation
                    var (recordDecl, compilation) = tuple;
                    var semanticModel = compilation.GetSemanticModel(recordDecl.SyntaxTree);

                    // Get the symbol for the record (entity)
                    var symbol = semanticModel.GetDeclaredSymbol(recordDecl);
                    if (symbol == null)
                    {
                        return;
                    }

                    // Get the namespace and class name for the entity
                    var ns = symbol.ContainingNamespace.ToDisplayString();
                    var className = symbol.Name;

                    // Get all properties of the entity
                    var props = symbol.GetMembers().OfType<IPropertySymbol>().ToList();

                    // Generate the switch cases for all properties (for value conversion)
                    var propertyCases = GeneratePropertyCases(props);

                    // Generate the full source code for the filter helper class
                    var source = GenerateHelperSource(ns, className, propertyCases);

                    // Add the generated source to the compilation
                    spc.AddSource($"{className}FilterHelper.g.cs", SourceText.From(source, Encoding.UTF8));
                });
        }

        /// <summary>
        ///     Generates the full source code for the filter helper class.
        /// </summary>
        /// <param name="ns">The namespace of the entity.</param>
        /// <param name="className">The class name of the entity.</param>
        /// <param name="propertyCases">The generated switch cases for all properties.</param>
        /// <returns>The complete C# source code for the filter helper class.</returns>
        private static string GenerateHelperSource(string ns, string className, string propertyCases)
        {
            // The generated class provides a ConvertValue method for converting string values to the correct property type
            return $@"
                    // <auto-generated/>
                    using System;
                    using System.Globalization;
                    namespace {ns}
                    {{
                        public static class {className}FilterHelper
                        {{
                            /// <summary>
                            /// Converts a string value to the correct property type for filtering.
                            /// </summary>
                            public static object ConvertValue(string propertyName, string value)
                            {{
                                switch (propertyName)
                                {{
                                    {propertyCases}
                                    default: throw new ArgumentException(""Unknown property: "" + propertyName);
                                }}
                            }}
                        }}
                    }}";
        }

        /// <summary>
        ///     Generates the switch cases for each property in the entity.
        ///     Each case converts a string value to the correct property type for that property.
        /// </summary>
        private static string GeneratePropertyCases(List<IPropertySymbol> props)
        {
            // For each property, generate a case statement for the switch
            return string.Join("\n", props.Select(prop =>
            {
                var type = prop.Type.ToDisplayString();
                // Get the code to convert a string to the correct type for this property
                var parseCode = GetParseCode(type, prop.Type.TypeKind);
                // Return the case statement for this property
                return $"                case \"{prop.Name}\": return {parseCode}";
            }));
        }

        /// <summary>
        ///     Returns the code to parse a string value to the correct property type.
        ///     Handles common .NET types, enums, and falls back to Convert.ChangeType for others.
        /// </summary>
        private static string GetParseCode(string type, TypeKind typeKind)
        {
            // Handle all supported property types
            if (type == "decimal")
            {
                return "decimal.Parse(value, CultureInfo.InvariantCulture);";
            }

            if (type == "double")
            {
                return "double.Parse(value, CultureInfo.InvariantCulture);";
            }

            if (type == "float")
            {
                return "float.Parse(value, CultureInfo.InvariantCulture);";
            }

            if (type == "System.DateTime" || type == "DateTime")
            {
                return "DateTime.Parse(value, CultureInfo.InvariantCulture);";
            }

            if (type == "System.Guid" || type == "Guid")
            {
                return "Guid.Parse(value);";
            }

            if (typeKind == TypeKind.Enum)
            {
                return $"Enum.Parse(typeof({type}), value);";
            }

            if (type == "bool" || type == "System.Boolean")
            {
                return "bool.Parse(value);";
            }

            if (type == "string" || type == "System.String")
            {
                return "value;";
            }

            // Fallback for other types (e.g., int, long, etc.)
            return $"Convert.ChangeType(value, typeof({type}), CultureInfo.InvariantCulture);";
        }
    }
}